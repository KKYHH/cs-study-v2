# [네트워크] HTTP

<br>

## 웹의 동작 방식

### 클라이언트와 서버

웹에 연결된 컴퓨터는 **클라이언트**와 **서버** 라고 한다.

- 클라이언트는 일반적인 웹 사용자의 인터넷이 연결된 장치들 (예: WI-FI,모바일 네트워크)과 이런 장치들에서 이용가능한 웹에 접근하는 소프트웨어(크롬,Firefox 같은 브라우저)이다.
- 서버는 웹페이지,사이트 또는 앱을 저장하는 컴퓨터다. 클라이언트의 장비가 웹페이지에 접근하길 원할 때, 서버로부터 클라이언트의 장치로 사용자의 웹 브라우저에서 보여지기 위한 웹페이지의 사본이 다운로드 된다.

<br>

### URI,URL,URN의 차이

- URL,URN은 URI에 포함되는 개념이며 URL은 자원의 위치,URN은 자원의 이름을 말한다.
- URI는 식별학,URL은 위치를 가리킨다.

<img src="https://github.com/CHZZK-Study/cs-study/assets/102516350/15fbec16-7bd1-48a7-8741-e63e3c983cd4">

**URI (Uniform resource Identifier)**

- 인터넷에 있는 자원을 나타내는 유일한 주소이다.URI는 인터넷에서 요구되는 기본 조건으로서 인터넷 프로토콜에 항상 붙어 다닌다
- URI안에 하위 개념으로 URN,URL이 존재한다.

**URN (Uniformed Resource Name)**

- 통합 자원 이름(URN)은 `urn:scheme` 을 사용하는 URI를 위한 역사적인 이름이다.
- URL이 리소스가 있는 위치를 지정한다면,URN은 리소스에 이름을 부여하는 것이다.
- URN은 영속적이고, 위치에 독립적인 자원을 위한 지시자로 사용하기 위해 1997년도 RFC 2141 문서에서 정의 되었다.
- 하지만 리소스가 이름에 매핑되어 있어야 하기 때문에 이름으로 부여하면 거의 찾기가 힘들다. 그래서 대부분 URL만 쓴다. (즉 URN은 몰라도 상관 없다)

**URL (Uniform Resource Locator)**

- 파일식별자(URL)는 네트워크 상에서 **자원이 어디 있는지 위치**를 알려주기 위한 규약이다
- 즉,컴퓨터 네트워크와 검색 메커니즘에서의 위치를 지정하는, 웹 리소스에 대한 참조이다.
- 흔히 우리는 URL을 웹사이트 주소로만 알고 있지만,URL은 웹 사이트 주소뿐만 아니라 컴퓨터 네트워크상의 자원을 모두 나타내는 표기법이다.
- 그리고 해당 주솟에 접속하려면 URL에 맞는 프로토콜(http,sftp,smp)를 알아야 하고,그와 동일한 프로토콜로 접속해야 한다.

예:

```jsx
google.com;
```

이것은 **URI다. 이유는 문자열만 있기 때문이다.**

```jsx
https://google.com
```

이것은 **URL이다. 이유는 문자열(google.com)과 프로토콜(https://)을 가지고 있기 때문이다.**

<img src="https://github.com/CHZZK-Study/cs-study/assets/102516350/adbfd3f7-6ece-41f9-8bc0-a6f478f1741b">

<br>

### URI / URL / URN 구분하기

<img src="https://github.com/CHZZK-Study/cs-study/assets/102516350/288bfff5-87f5-431e-aa02-a098416050e2">

인터넷 상의 자원의 위치(URL)와 자원의 식별자(URI)는 언뜻 보면 같은 것을 의미하는 듯 하지만 ‘자원의 위치’라는 것은 결국 ‘하나의 파일 위치’를 나타내는 것임을 생각하자.

아래 주소를 예시로 구분해보자

```
http://www.naver.com/index.html?page=1232950&id=776
```

[http://www.naver.com/](http://www.naver.com/) 서버에 위치한 index.html 페이지는 query string인 page의 값에 따라 여러가지 화면 결과를 나타나게 된다.

이 때 여기서 URL은 index.html의 위치를 표기한 [http://www.naver.com/index.html](http://www.naver.com/index.html) 까지이다.

하지만 사용자가 원하는 정보에 도달 하기 위해서는 ?page=1232950&id=776 라는 식별자(Identifier)가 필요한 것이다.

따라서 구분하자면 위 예시 주소는 URI이고,식별자가 빠진 [http://www.naver.com/index.html](http://www.naver.com/index.html을)를 URL이라고 하는 것이다.

**URL은 자원의 위치**를 나타내 주는 것이고 **URI는 자원의 식별자**인데, ?page=1232950&id=776 이 부분은 위치를 나타내는 것이 아니라 page값이 1232950이고 id가 776인 것을 나타내는 **식별하는 부분이기 때문이다.**

통상적으로 통틀어 URL이라고 하지만 엄격하게는 URI라고 하는 것이 맞다.

```
http://www.naver.com/index.html?page=1232950&id=776
http://www.naver.com/index.html?page=9923145&id=122
```

그렇기에 위 두 주소는 같은 URL이고 다른 URI라고 할 수 있다

<br>
<br>

# HTTP의 기본 개념

### HTTP 개요

- HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜이다
- HTTP는 웹에서 이루어지는 모든 데이터 교환의 기초이며,클라이언트-서버 프로토콜이기도 하다.
- 클라이언트-서버 프로토콜이란 수신자 측에 의해 요청이 초기화되는 프로토콜을 의미한다.
- 하나의 완전한 문서는 텍스트,레이아웃 설명,이미지,비디오,스크립트 등 불러온(fetched) 하위 문서들로 재구성된다.

클라이언트와 서버들은 개별적인 메시지 교환에 의해 통신한다. 보통 브라우저인 클라이언트에 의해 전송되는 메시지를 요청(requests)이라고 부르며, 그에 대해 서버에서 응답으로 전송되는 메시지를 응답(responses)라고 부른다.

<br>

### HTTP 시스템 구성요소

1. **클라이언트: 사용자 에이전트**
   - 브라우저는 주로 사용자 에이전트로서 동작하며 웹 페이지의 HTML,스크립트,이미지 등을 요청하여 표시한다.
   - 브라우저는 사용자의 상호 작용에 따라 웹 페이지 갱신 및 새로운 요청을 생성한다.
   - 브라우저는 HTTP 요청을 통해 서버에 요청을 보내고 응답을 받아 사용자에게 표시한다.
2. **웹 서버**
   - 서버는 클라이언트의 요청에 대한 문서를 제공한다. 서버는 논리적으로 단일 기계일 수도 있고 여러 서버의 집합일 수도 있다.
   - 클라이언트의 요청에 따라 HTML,이미지,스크립트 등의 리소스를 생성하거나 전송한다.
3. **프록시**

   - 프록시는 클라이언트와 서버 사이에서 동작하는 중간 컴퓨터/머신으로,HTTP 메시지를 전달하거나 변경하는 역할을 한다.
   - 프록시는 캐싱,필터링,로드 밸런싱,인증,로깅 등 다양한 기능을 수행할 수 있다.

<img src="https://github.com/CHZZK-Study/cs-study/assets/102516350/dcc72ce3-b61a-48bf-84f9-b2128f7e1881">

<br>

HTTP는 사용자 에이전트와 서버 간의 요청과 응답을 중심으로 동작하며,프록시를 통해 추가적인 기능을 제공한다. 클라이언트는 브라우저와 같은 사용자 에이전트로서 동작하며 서버는 요청에 따라 문서 및 리소스를 제공한다.프록시는 중간에서 다양한 역할을 수행하여 웹 통신을 개선하고 보안등을 관리한다.

<br>

### HTTP 제어

HTTP는 간단하고 읽기 쉬운 프로토콜로,확장 가능성이 뛰어나다.

주로 사용자 에이전트(브라우저)와 서버 간의 요청 및 응답을 다루며,이를 통해 웹의 다양한 기능들을 제어한다.

1. **간결하고 확장 가능한 설계**
   - HTTP는 간단하게 고안되어 있어서 사람이 읽고 이해하기 쉽다.
   - 헤더를 활용하여 HTTP를 확장하고 새로운기능을 추가할 수 있다.
2. **상태는 없지만 세션을 유지**
   - HTTP는 상태를 저장하지 않지만(Stateless),쿠키를 사용하여 상태가 있는 세션을 유지할 수 있다.
   - 연결이 없는 상태에서 각 요청 간에 세션을 만들 수 있도록한다.
3. **연결과 TCP**
   - 연결은 전송 계층에서 제어되므로 근본적으로 HTTP 영역 밖이다
   - 다만 신뢰할 수 있거나 메시지 손실이 없는 연결을 요구할 뿐이다
   - HTTP는 연결 지향적인 프로토콜은 아니지만 주로 TCP를 기반으로 동작한다.
   - TCP 연결을 설정하고 유지하여 클라이언트와 서버 간의 통신을 담당한다.
4. **클라이언트-서버 통신**
   - 클라이언트(브라우저)가 서버에 요청을 보내고,서버가 응답을 제공하는 구조를 가진다
   - HTTP 메시지를 통해 요청과 응답이 이루어진다.
5. **프록시와 확장 가능한 제어**
   - 프록시를 사용하여 중간에서 HTTP 메시지를 전달하거나 변경할 수 있다.
   - HTTP를 통해 캐시,인증,프록시,프라이버시 제어 등 다양한 기능을 제어할 수 있다.
6. **세션과 인증**
   - 쿠키를 사용하여 세션을 생성하고 유지하며,인증을 통해 접근 제어를 할 수 있다.
   - 사용자 에이전트가 서버에 대한 요청과 응답 사이에서 세션을 관리한다.

<br>

### HTTP 메시지

**요청**

<img src="https://github.com/CHZZK-Study/cs-study/assets/102516350/bb0eff77-332a-4d0e-904f-f9042d74536a">

**Method**

HTTP 메서드,클라이언트가 수행하고자 하는 동작을 정의한 `GET` , `POST` 같은 동사나 `OPTIONS` 나 `HEAD` 와 같은 명사이다. 일반적으로, 클라이언트는 리소스를 가져오거나(`GET` 을 사용하여) HTML 폼의 데이터를 전송(`POST` 를 사용하여)하려고 하지만, 다른 경웅에는 다른 동작이 요구될 수도 있다.

**Path**

가져오려는 리소스의 경로

예를 들면 프로토콜(`http://`)d,도메인,또는TCP 포트인 요소들을 제거한 리소스의 URL

**Version of the protocol**

HTTP 프로토콜의 버전

**Headers**

서버에 대한 추가 정보를 전달하는 선택적 헤더들

**응답**

<img src="https://github.com/CHZZK-Study/cs-study/assets/102516350/2a547dc1-a51e-4b93-8ab9-5b9636ca62bc">

**Version of the protocol**

HTTP 프로토콜의 버전

**Status code**

요청의 성공 여부와, 그 이유를 나타내는 상태코드

**Status message**

상태 코드의 짧은 설명을 나타내는 상태 메시지

**Headers**

요청 헤더와 비슷한 HTTP 헤더들

<br>

### HTTP 요청 메서드

**주요 메서드 5가지**

1. **GET:** 리소스 조회
2. **POST:** 요청 데이터 처리, 주로 데이터 등록에 사용
3. **PUT:** 리소스를 대체, 해당 리소스가 없으면 생성
4. **PATCH:** 리소스를 일부만 변경
5. **DELETE:** 리소스 삭제

<br>

**기타 메서드 4가지**

1. **HEAD:** `GET` 과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
2. **CONNECT:** 대상 자원으로 식별되는 서버에 대한 터널을 설정
3. **OPTIONS:** 대상 리소스에 대한 통신 가능 옵션을 설명 (주로 `CORS`에서 사용)
4. **TRACE:** 대상 리소스에 대댛로 를로 따라 시메지시루백프스 테 스숳 수행

<br>

### HTTP 메서드의 속성

1. 안전(Safe Methods)

   이 말은 계속해서 메서드를 호출핻도 리소스를 변경하지 않는다는 뜻이다.

   주요 메서드중에는 `GET` 메서드가 안전하다고 볼 수 있다.

1. 멱등(Idempotent Methods)

   이 말은 메서드를 계속 호추래도 결과가 똑같다는 뜻이다.

   `GET`,`PUT`,`DELETE`는 멱등하다고 볼 수 있지만 `POST`나 `PATCH`는 멱등하다고 볼 수 없다.

1. 캐시가능(Cacheable Methods)

   캐시가능하다는 말은 말 그대로 캐싱을 해서 데이터를 효율적으로 가져올 수 있다는 뜻이다.

   `GET`,`HEAD`,`POST`,`PATCH` 가 캐시가 가능하지만 실제로는 `GET`과 `HEAD`만 주로 캐싱이 쓰인다고 한다.

- 안전한 메서드(**`GET`**)는 호출해도 서버의 상태나 데이터를 바꾸지 않습니다.
- 멱등한 메서드(**`GET`**, **`PUT`**, **`DELETE`**)는 여러 번 호출해도 동일한 결과를 얻습니다.
- 캐시가능한 메서드(**`GET`**, **`HEAD`**, **`POST`**, **`PATCH`**)는 응답을 캐시에 저장하여 효율적으로 활용할 수 있습니다.

<br>

### HTTP 상태 코드

HTTP 상태 코드는 서버가 클라이언트에게 요청의 성공,실패,혹은 리디렉션 등의 상태를 알려주는 세 자리 숫자이다. 각각의 숫자 그룹은 상태 코드의 범주를 나타내며, 세 자리 중간의 숫자는 상태를 더 세분화한다.

일반적으로 세 자리 숫자 중 첫 번째 숫자는 상태 코드의 클래스를 나타낸다.

1xx (Informational): 요청이 수신되어 처리중

2xx (Successful): 요청 정상 처리

3xx (Redirection): 요청을 완료하려면 추가 행동이 필요

4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음

5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함

<br>

### **주요 상태 코드**

### **1xx(Informational) - 정보성 응답**

- **100 Continue**
- 클라이언트가 요청을 계속할 수 있음을 나타낸다. 거의 사용되지 않는다고 한다.

### **2xx (Successful) - 성공적인 응답**

- **200 OK**
- 요청이 성공적으로 처리 되었음을 나타낸다.

- **201 Created**
- 요청이 성공적으로 처리되어 새로운 리소스가 생성되었음을 나타낸다.

- **204 No Content**
- 서버가 요청을 성공적으로 처리했지만 응답 본문에 데이터가 없음을 나타낸다.

### 3xx (Redirection) - 리디렉션

- **301 Moved Permanently**
- 요청한 리소스가 새로운 위치로 옮겨졌으며, 이후의 요청은 새로운 위치를 사용해야 함을 나타낸다.

- **302 Found (or Moved Temporarily)**
- 요청한 리소스가 일시적으로 다른 위치로 옮겨졌으며,이후의 요청은 원래 위치를 사용해야 함을 나타낸다.

- **304 Not Modified**
- 클라이언트가 이미 가지고 있는 리소스가 수정되지 않았음을 나타내어,클라이언트는 캐시된 데이터를 계속 사용할 수 있다.

### 4xx (Client Error) - 클라이언트 오류

- **400 Bad Request**
- 서버가 요청을 이해하지 못하거나,유효하지 않은 요청임을 나타낸다.

- **401 Unauthorized**
- 인증이 필요함을 나타내며,클라이언트는 인증 헤더를 제공하여 다시 시도해야 한다.

- **403 Forbidden**
- 클라이언트가 요청한 리소스에 접근할 권한이 없음을 나타낸다.

- **404 Not Found**
- 요청한 리소스를 서버에서 찾을 수 없음을 나타낸다

### 5xx (Server Error) - 서버 오류

- **500 Internal Server Error**
- 서버가 요청을 처리하는 중에 오류가 발생했음을 나타낸다.

- **502 Bad Gateway**
- 게이트웨이나 프록시 서버가 유효하지 않은 응답을 받았음을 나타낸다.

- **503 Service Unavailable**
- 서버가 현재 서비스를 제공할 수 없음을 나타낸다. 이는 일시적인 상태일 수 있다

<br>

### POST 방식이 GET 방식보다 보안측면에서 더 좋다?

`GET`과 비교하여 `URL`에 데이터의 정보가 들어 있지 않으므로 조금 더 안전하다고 볼 수 있다

### GET 방식이 POST 방식보다 속도가 빠르다?

`GET` 방식은 캐싱을 하기 때문에 여러번 요청시 저장된 데이터를 활용하므로 조금 더 빠를 수 있다.

### POST vs PUT

`POST`와 `PUT`은 구분해서 사용해야한다. `POST`는 새로운 데이터를 계속 생성하기 때문에 요청시마다 데이터를 생성하지만, `PUT`은 사용자가 데이터를 지정하고 수정하는 것이기 때문에 같은 요청을 계속 하더라도 데이터가 계속 생성되지 않는다.

### PUT vs PATCH

`PUT`은 지정한 데이터를 전부 수정하는 `Method`이지만 `PATCH`는 정보의 일부분이 변경되는 방법이다. 그래서 `PUT`은 멱등하지만, `PATCH`는 멱등하다고 볼 수 없다.
